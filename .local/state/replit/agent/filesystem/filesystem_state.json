{"file_contents":{"README.md":{"content":"Multi-View Video Sync (2×2)\n\nFastAPI backend with yt-dlp extraction and a plain JS frontend that loads four synchronized video panes (2×2). Master controls play/pause/seek/rate/volume/mute across all panes with periodic drift correction.\n\nStack\n- Backend: FastAPI, uvicorn, yt-dlp, slowapi (rate limiting)\n- Frontend: Plain HTML/CSS/JS, hls.js, YouTube IFrame API\n\nSetup (Windows/PowerShell)\n```powershell\ncd C:\\Users\\<you>\\OneDrive\\Desktop\\cursor\npy -3 -m venv backend\\venv\nbackend\\venv\\Scripts\\python.exe -m pip install --upgrade pip\nbackend\\venv\\Scripts\\python.exe -m pip install fastapi \"uvicorn[standard]\" yt-dlp slowapi\n```\n\nRun the server:\n```powershell\nbackend\\venv\\Scripts\\python.exe -m uvicorn backend.app.main:app --reload --host 0.0.0.0 --port 8000\n```\n\nOpen the app:\n- Navigate to `http://localhost:8000/`\n\nAPI\nPOST `/api/fetch`\nRequest body:\n```json\n{ \"url\": \"https://www.youtube.com/watch?v=ABCDEFG\" }\n```\nSuccess response example:\n```json\n{\n  \"status\": \"ok\",\n  \"provider\": \"youtube\",\n  \"title\": \"Example Video Title\",\n  \"duration\": 124.5,\n  \"sources\": [\n    {\"type\": \"hls\", \"url\": \"https://.../playlist.m3u8\"},\n    {\"type\": \"mp4\", \"url\": \"https://.../video_720.mp4\"}\n  ],\n  \"ttl_seconds\": 3600\n}\n```\nError example:\n```json\n{ \"status\": \"error\", \"message\": \"Geo-blocked or unsupported provider\" }\n```\n\ncURL example:\n```bash\ncurl -X POST http://localhost:8000/api/fetch \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"url\":\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\"}'\n```\n\nNotes\n- Only YouTube/Vimeo are allowed (safelist). Others return an error.\n- Many URLs expire; the app shows a TTL hint and you can reload URLs if needed.\n- Autoplay may be blocked by browsers; press Play to start all.\n- YouTube may fall back to iframe control if direct streams are not accessible.\n- Drift correction runs every ~1s; if drift > 300ms, a soft seek realigns.\n\nSecurity & Legality\n- Respects provider ToS; no paywalled/login-protected streams.\n- Includes simple rate-limiting via slowapi.\n\n\n","size_bytes":1998},"replit.md":{"content":"# Multi-View Video Sync Application\n\n## Overview\nThis is a full-stack web application that allows users to load and synchronize up to 4 videos simultaneously in a 2x2 grid layout. It supports YouTube and Vimeo videos with master controls for play/pause/seek/volume across all panes, including automatic drift correction.\n\n## Current State\n✅ **FULLY CONFIGURED AND RUNNING**\n- Flask backend serving both API and static files on port 5000\n- Frontend with video synchronization features working\n- API tested with YouTube video extraction\n- Deployment configured for production\n\n## Technology Stack\n- **Backend**: Python Flask, yt-dlp, asyncio\n- **Frontend**: Plain HTML/CSS/JavaScript, hls.js, YouTube IFrame API\n- **Video Processing**: yt-dlp for video extraction, HLS.js for streaming\n\n## Project Architecture\n```\n├── backend/\n│   └── app/\n│       └── main.py          # Flask server (API + static file serving)\n├── frontend/\n│   └── public/\n│       ├── index.html       # Main UI with 2x2 video grid\n│       └── app.js          # Video sync logic, player management\n├── requirements.txt         # Python dependencies\n└── README.md               # Original project documentation\n```\n\n## Key Features\n1. **Multi-pane video loading**: 4 synchronized video players in 2x2 grid\n2. **Video extraction**: Uses yt-dlp to extract playable streams from YouTube/Vimeo\n3. **Master controls**: Global play/pause/seek/volume/speed controls\n4. **Drift correction**: Automatic synchronization every 1s with 300ms tolerance\n5. **Multiple formats**: Supports both MP4 direct streams and HLS streaming\n6. **Responsive design**: Clean dark theme with modern UI\n\n## Recent Changes\n- **2025-09-25**: Initial Replit environment setup\n  - Installed Python 3.11 and Flask dependencies\n  - Configured Flask server for Replit (0.0.0.0:5000, cache control headers)\n  - Set up workflow for combined frontend/backend serving\n  - Tested API functionality with YouTube video extraction\n  - Configured autoscale deployment for production\n\n## API Usage\n```bash\n# Test video extraction\ncurl -X POST http://localhost:5000/api/fetch \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"url\":\"https://www.youtube.com/watch?v=dQw4w9WgXcQ\"}'\n```\n\n## Deployment\n- **Target**: Autoscale (stateless web application)\n- **Command**: `python backend/app/main.py`\n- **Port**: 5000 (serves both API and static files)\n\n## User Preferences\n- Clean, minimal setup maintaining original architecture\n- Single Flask server handling both backend API and frontend serving\n- Focus on video synchronization functionality","size_bytes":2625},"backend/app/main.py":{"content":"﻿from flask import Flask, request, jsonify, send_from_directory, make_response\nfrom pathlib import Path\nimport urllib.parse as up\nfrom typing import List\nimport yt_dlp\nimport asyncio\nfrom contextlib import asynccontextmanager\ntry:\n    from playwright.async_api import async_playwright\n    PLAYWRIGHT_AVAILABLE = True\nexcept Exception:\n    PLAYWRIGHT_AVAILABLE = False\n\n# Resolve absolute path to frontend/public to avoid 404 from relative CWD\nPROJECT_ROOT = Path(__file__).resolve().parents[2]\nPUBLIC_DIR = PROJECT_ROOT / 'frontend' / 'public'\napp = Flask(__name__, static_folder=str(PUBLIC_DIR), static_url_path='/static')\n\nSAFE_PROVIDERS = {'youtube', 'youtu.be', 'vimeo'}\n\n\n@app.after_request\ndef add_cors_headers(resp):\n    resp.headers['Access-Control-Allow-Origin'] = '*'\n    resp.headers['Access-Control-Allow-Methods'] = 'GET,POST,OPTIONS'\n    resp.headers['Access-Control-Allow-Headers'] = 'Content-Type'\n    # Add cache control to prevent caching issues in Replit environment\n    resp.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'\n    resp.headers['Pragma'] = 'no-cache'\n    resp.headers['Expires'] = '0'\n    return resp\n\n\n@app.route('/')\ndef index():\n    return send_from_directory(str(PUBLIC_DIR), 'index.html')\n\n@app.route('/index.html')\ndef index_html():\n    return send_from_directory(str(PUBLIC_DIR), 'index.html')\n\n@app.route('/movies')\ndef movies():\n    return send_from_directory(str(PUBLIC_DIR), 'movies.html')\n\n\n@app.route('/api/fetch', methods=['POST', 'OPTIONS'])\ndef fetch():\n    if request.method == 'OPTIONS':\n        return make_response(('', 204))\n\n    data = request.get_json(silent=True) or {}\n    url = (data.get('url') or '').strip()\n    if not url:\n        return jsonify({'status': 'error', 'message': 'Missing URL'}), 400\n\n    try:\n        parsed = up.urlparse(url)\n        host = (parsed.netloc or '').lower()\n    except Exception:\n        return jsonify({'status': 'error', 'message': 'Invalid URL'}), 400\n    # Allow any host; yt-dlp will attempt extraction and may still fail for DRM/login/geo-block\n\n    # Forward useful headers from the browser to improve success rate\n    ua = request.headers.get('User-Agent') or 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36'\n    ref = request.headers.get('Referer') or url\n    cookie = request.headers.get('Cookie')\n    accept_lang = request.headers.get('Accept-Language') or 'en-US,en;q=0.9'\n\n    ydl_opts = {\n        'quiet': True,\n        'no_warnings': True,\n        'noplaylist': True,\n        'skip_download': True,\n        'restrictfilenames': True,\n        'extractor_args': {\n            # Hint yt-dlp to impersonate a modern Chrome for generic/spankbang\n            'generic': {'impersonate': ['chrome']},\n            'spankbang': {'impersonate': ['chrome']},\n        },\n        'http_headers': {\n            'User-Agent': ua,\n            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',\n            'Accept-Language': accept_lang,\n            'Referer': ref,\n            **({'Cookie': cookie} if cookie else {}),\n        },\n    }\n    try:\n        with yt_dlp.YoutubeDL(ydl_opts) as ydl:\n            info = ydl.extract_info(url, download=False)\n    except yt_dlp.utils.DownloadError as e:\n        # Try Playwright fallback for sites blocking API (e.g., 403)\n        if PLAYWRIGHT_AVAILABLE:\n            meta = asyncio.run(_playwright_extract(url))\n            if meta:\n                return jsonify({'status': 'ok', 'provider': 'playwright', 'title': meta.get('title'), 'duration': None, 'sources': meta['sources'], 'ttl_seconds': 1800})\n        return jsonify({'status': 'error', 'message': str(e)})\n    except Exception:\n        return jsonify({'status': 'error', 'message': 'Extraction failed'})\n\n    title = info.get('title')\n    duration = info.get('duration')\n    extractor = (info.get('extractor_key') or 'unknown').lower()\n\n    # Rank formats and pick the single best quality (prefer highest resolution/bitrate)\n    fmts = info.get('formats') or []\n    candidates: List[dict] = []\n    for f in fmts:\n        f_url = f.get('url')\n        if not f_url:\n            continue\n        proto = (f.get('protocol') or '')\n        ext = (f.get('ext') or '')\n        vcodec = f.get('vcodec')\n        acodec = f.get('acodec')\n        # Skip audio-only\n        if vcodec == 'none':\n            continue\n        # Type\n        typ = 'hls' if 'm3u8' in proto else ('mp4' if ext == 'mp4' else None)\n        if not typ:\n            continue\n        height = f.get('height') or 0\n        width = f.get('width') or 0\n        tbr = f.get('tbr') or 0  # total bitrate\n        size = f.get('filesize') or f.get('filesize_approx') or 0\n        # Score: resolution first, then bitrate, then known filesize\n        score = int(height * width) * 1_000 + int(tbr * 1_000) + int(size)\n        candidates.append({'type': typ, 'url': f_url, 'score': score})\n\n    if not candidates:\n        return jsonify({'status': 'error', 'message': 'No playable sources found'})\n\n    best = max(candidates, key=lambda c: c['score'])\n    return jsonify({\n        'status': 'ok',\n        'provider': extractor,\n        'title': title,\n        'duration': float(duration) if duration is not None else None,\n        'sources': [{'type': best['type'], 'url': best['url']}],\n        'ttl_seconds': 3600,\n    })\n\n\nasync def _playwright_extract(page_url: str):\n    try:\n        async with async_playwright() as p:\n            browser = await p.chromium.launch(headless=True)\n            context = await browser.new_context(\n                user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0 Safari/537.36',\n                ignore_https_errors=True,\n            )\n            page = await context.new_page()\n            await page.route('**/*', lambda route: route.continue_())\n            await page.goto(page_url, wait_until='domcontentloaded', timeout=45000)\n            # Wait a bit for players to initialize\n            await page.wait_for_timeout(3000)\n\n            # Try to find m3u8/mp4 URLs in network logs\n            found = []\n            for req in page.context.requests:\n                u = req.url\n                if '.m3u8' in u or '.mp4' in u:\n                    typ = 'hls' if '.m3u8' in u else 'mp4'\n                    found.append({'type': typ, 'url': u})\n            if not found:\n                # Fallback: scan HTML\n                html = await page.content()\n                import re\n                m3u8s = set(re.findall(r'https?://[^\"\\'\\s>]+\\.m3u8[^\"\\'\\s<]*', html, flags=re.IGNORECASE))\n                mp4s = set(re.findall(r'https?://[^\"\\'\\s>]+\\.mp4[^\"\\'\\s<]*', html, flags=re.IGNORECASE))\n                for u in m3u8s:\n                    found.append({'type': 'hls', 'url': u})\n                for u in mp4s:\n                    found.append({'type': 'mp4', 'url': u})\n\n            await context.close()\n            await browser.close()\n            if not found:\n                return None\n            # Return best-priority first: prefer MP4\n            found.sort(key=lambda s: 0 if s['type']=='mp4' else 1)\n            return {'title': None, 'sources': found[:2]}\n    except Exception:\n        return None\n\n\nif __name__ == \"__main__\":\n    # For Replit environment: bind to 0.0.0.0:5000 for frontend access\n    # Since this Flask app serves both API and static files, it acts as the frontend server\n    app.run(host=\"0.0.0.0\", port=5000, debug=True)\n","size_bytes":7527},"frontend/public/app.js":{"content":"﻿(function(){\n  const NUM_PANES = 4;\n  const grid = document.getElementById('grid');\n  const state = { masterDuration: 0, lastKnownTime: 0, syncing: false, mutedAll: false };\n\n  function createPane(index){\n    const pane = document.createElement('div');\n    pane.className = 'pane';\n    pane.dataset.index = index;\n\n    const topbar = document.createElement('div');\n    topbar.className = 'topbar';\n    const input = Object.assign(document.createElement('input'), { type:'text', placeholder:'Paste video URL...' });\n    const loadBtn = Object.assign(document.createElement('button'), { textContent:'Load' });\n    topbar.append(input, loadBtn);\n\n    const status = document.createElement('div');\n    status.className = 'status';\n    status.textContent = 'Idle';\n\n    const videoWrap = document.createElement('div');\n    videoWrap.className = 'video-wrap';\n\n    const small = document.createElement('div');\n    small.className = 'small-controls';\n    const muteBtn = Object.assign(document.createElement('button'), { textContent:'Mute' });\n    const hideBtn = Object.assign(document.createElement('button'), { textContent:'Hide' });\n    const gadBtn = Object.assign(document.createElement('button'), { textContent:'GAD' });\n    small.append(muteBtn, hideBtn, gadBtn);\n    videoWrap.appendChild(small);\n\n    const container = document.createElement('div');\n    container.style.position = 'absolute';\n    container.style.left = '0';\n    container.style.top = '0';\n    container.style.right = '0';\n    container.style.bottom = '0';\n    videoWrap.appendChild(container);\n\n    // Create individual controls container\n    const individualControls = document.createElement('div');\n    individualControls.className = 'individual-controls';\n    individualControls.style.display = 'none'; // Hidden by default\n    \n    // Individual control elements\n    const indPlayBtn = Object.assign(document.createElement('button'), { textContent:'Play' });\n    const indPauseBtn = Object.assign(document.createElement('button'), { textContent:'Pause' });\n    const indSeek = Object.assign(document.createElement('input'), { \n      type:'range', min:'0', max:'100', step:'0.01', value:'0', className:'individual-seek'\n    });\n    const indCurTime = Object.assign(document.createElement('span'), { \n      textContent:'0:00', className:'time-badge'\n    });\n    const indDurTime = Object.assign(document.createElement('span'), { \n      textContent:'0:00', className:'time-badge' \n    });\n    \n    // Individual speed control for this video only\n    const indSpeedSelect = document.createElement('select');\n    indSpeedSelect.innerHTML = `\n      <option value=\"0.5\">0.5x</option>\n      <option value=\"1\" selected>1x</option>\n      <option value=\"1.5\">1.5x</option>\n      <option value=\"2\">2x</option>\n      <option value=\"5\">5x</option>\n    `;\n    \n    individualControls.append(indPlayBtn, indPauseBtn, indCurTime, indSeek, indDurTime, indSpeedSelect);\n    \n    pane.append(topbar, status, videoWrap, individualControls);\n\n    const player = buildPlayer(container, status);\n\n    loadBtn.addEventListener('click', async ()=>{\n      const url = input.value.trim();\n      if(!url){ setStatus(status, 'Please paste a URL'); return; }\n      await loadUrlIntoPlayer(url, player, status);\n    });\n\n    muteBtn.addEventListener('click', ()=>{\n      player.setMuted(!player.isMuted());\n      muteBtn.textContent = player.isMuted() ? 'Unmute' : 'Mute';\n    });\n\n    hideBtn.addEventListener('click', ()=>{\n      if(container.style.display === 'none'){ container.style.display = ''; hideBtn.textContent = 'Hide'; }\n      else { container.style.display = 'none'; hideBtn.textContent = 'Show'; }\n    });\n\n    // GAD button to toggle individual controls\n    gadBtn.addEventListener('click', ()=>{\n      if(individualControls.style.display === 'none'){\n        individualControls.style.display = 'flex';\n        gadBtn.textContent = 'Hide Controls';\n      } else {\n        individualControls.style.display = 'none'; \n        gadBtn.textContent = 'GAD';\n      }\n    });\n\n    // Individual control event handlers (only for this video)\n    indPlayBtn.addEventListener('click', async ()=>{ \n      await player.play(); \n    });\n    \n    indPauseBtn.addEventListener('click', ()=>{ \n      player.pause(); \n    });\n    \n    indSeek.addEventListener('input', ()=>{\n      const t = Number(indSeek.value)||0;\n      indCurTime.textContent = hhmmss(t);\n      const max = Number(indSeek.max)||1; \n      const pct = Math.max(0, Math.min(100, (t/max)*100));\n      indSeek.style.setProperty('--seek-fill', pct+'%');\n    });\n    \n    indSeek.addEventListener('change', async ()=>{ \n      const t = Number(indSeek.value)||0; \n      await player.seekTo(t); \n    });\n\n    // Individual speed control event handler (only affects this video)\n    indSpeedSelect.addEventListener('change', ()=>{\n      const rate = Number(indSpeedSelect.value);\n      player.setRate(rate);\n    });\n\n    // Update individual controls periodically for this video only\n    setInterval(()=>{\n      if(individualControls.style.display !== 'none' && player.isReady()){\n        const currentTime = player.getCurrentTime() || 0;\n        const duration = player.getDuration() || 0;\n        \n        if(duration > 0){\n          const newMax = Math.max(10, Math.ceil(duration));\n          indSeek.max = String(newMax);\n          indSeek.value = String(Math.min(duration, currentTime));\n          indCurTime.textContent = hhmmss(currentTime);\n          indDurTime.textContent = hhmmss(duration);\n          \n          const pct = Math.max(0, Math.min(100, (currentTime/duration)*100));\n          indSeek.style.setProperty('--seek-fill', pct+'%');\n        }\n      }\n    }, 1000);\n\n    grid.appendChild(pane);\n    return { pane, input, loadBtn, status, player };\n  }\n\n  function setStatus(el, text){ el.textContent = text; }\n  function hhmmss(sec){ if(!isFinite(sec)) return '0:00'; const s = Math.floor(sec%60).toString().padStart(2,'0'); const m = Math.floor(sec/60)%60; const h = Math.floor(sec/3600); return (h>0? h+':'+String(m).padStart(2,'0') : m)+':'+s; }\n\n  function buildPlayer(mount, statusEl){\n    let type = 'empty';\n    let video = null; let hls = null; let yt = null; let ready = false; let provider = 'unknown'; let duration = 0; let title = '';\n\n    function destroy(){ if(hls){ hls.destroy(); hls=null; } if(video){ video.src=''; video.remove(); video=null; } if(yt){ try{ yt.destroy(); }catch(e){} yt=null; } ready=false; }\n\n    function ensureVideo(){ if(video) return video; const v = document.createElement('video'); v.playsInline = true; v.controls = false; v.muted = false; v.preload = 'auto'; v.crossOrigin = 'anonymous'; v.disablePictureInPicture = true; v.style.width = '100%'; v.style.height = '100%'; mount.appendChild(v); video = v; return v; }\n\n    return {\n      async loadFromSources(meta){\n        destroy(); provider = meta.provider || 'unknown'; title = meta.title || ''; duration = meta.duration || 0; const sources = meta.sources || [];\n        setStatus(statusEl, `Loading: ${title || provider} (${duration? hhmmss(duration):'--:--'})`);\n        // Prefer MP4 (lower CPU) when available\n        const mp4Src = sources.find(s=> s.type==='mp4');\n        const hlsSrc = sources.find(s=> s.type==='hls');\n        return await new Promise((resolve, reject)=>{\n          if(mp4Src){\n            type='mp4'; const v = ensureVideo();\n            const onMeta = ()=>{ v.removeEventListener('loadedmetadata', onMeta); duration = v.duration || duration; ready=true; setStatus(statusEl, `Ready (MP4) ${title}`); resolve(); };\n            v.addEventListener('loadedmetadata', onMeta, { once: true });\n            v.src = mp4Src.url;\n          } else if(hlsSrc){\n            type='hls'; const v = ensureVideo(); if(window.Hls && Hls.isSupported()){\n              hls = new Hls({\n              enableWorker: true,\n              lowLatencyMode: false,\n              capLevelToPlayerSize: true,\n              startLevel: -1,\n              backBufferLength: 15,\n              maxBufferLength: 10,\n              manifestLoadingRetryDelay: 1000,\n              levelLoadingRetryDelay: 1000,\n              fragLoadingRetryDelay: 1000,\n              manifestLoadingMaxRetry: 3,\n              levelLoadingMaxRetry: 3,\n              fragLoadingMaxRetry: 3,\n              });\n              hls.loadSource(hlsSrc.url);\n              hls.attachMedia(v);\n              let mediaErrorRecoveries = 0;\n              hls.on(Hls.Events.MANIFEST_PARSED, ()=>{ ready=true; duration = v.duration || duration; setStatus(statusEl, `Ready (HLS) ${title}`); mediaErrorRecoveries = 0; resolve(); });\n              hls.on(Hls.Events.ERROR, (evt, data)=>{\n              const detail = (data && (data.details || data.type)) || 'unknown';\n              if (!data) { setStatus(statusEl, 'HLS error'); return; }\n              if (data.fatal) {\n                if (data.type === Hls.ErrorTypes.NETWORK_ERROR) {\n                  setStatus(statusEl, 'HLS network error, retrying...');\n                  try { hls.startLoad(); } catch(e){}\n                } else if (data.type === Hls.ErrorTypes.MEDIA_ERROR && mediaErrorRecoveries < 2) {\n                  mediaErrorRecoveries++;\n                  setStatus(statusEl, 'HLS media error, recovering...');\n                  try { hls.recoverMediaError(); } catch(e){}\n                } else {\n                  setStatus(statusEl, 'HLS fatal: '+detail); reject(new Error(detail));\n                }\n              } else {\n                // Non-fatal, update status for visibility\n                setStatus(statusEl, 'HLS warn: '+detail);\n              }\n              });\n            }\n            else if(v.canPlayType('application/vnd.apple.mpegurl')){ v.addEventListener('loadedmetadata', ()=>{ ready=true; duration = v.duration || duration; setStatus(statusEl, `Ready (HLS native) ${title}`); resolve(); }, { once: true }); v.src = hlsSrc.url; }\n            else { setStatus(statusEl, 'HLS not supported'); reject(new Error('HLS not supported')); }\n          } else if(meta.provider === 'youtube'){\n            type='youtube'; const id = extractYouTubeId(meta.originalUrl || ''); if(!id){ setStatus(statusEl, 'YouTube ID not found'); reject(new Error('YouTube ID not found')); return; } const iframe = document.createElement('div'); mount.appendChild(iframe);\n            const waitYT = new Promise(res=>{ if(window.YT && window.YT.Player) res(); else { const iv = setInterval(()=>{ if(window.YT && window.YT.Player){ clearInterval(iv); res(); } }, 100); } });\n            waitYT.then(()=>{ yt = new YT.Player(iframe, { videoId:id, playerVars:{ controls:0, modestbranding:1, rel:0, disablekb:1 }, events:{ onReady:()=>{ ready=true; setStatus(statusEl, `Ready (YouTube) ${title}`); resolve(); }, onError:(e)=> { setStatus(statusEl, 'YT error '+(e && e.data)); reject(new Error('YT error')); } }}); });\n          } else {\n            setStatus(statusEl, 'No playable source'); reject(new Error('No playable source'));\n          }\n        });\n      },\n      getCurrentTime(){ if(type==='youtube') return yt? (yt.getCurrentTime()||0) : 0; if(video) return video.currentTime||0; return 0; },\n      async seekTo(t){ if(!ready) return; if(type==='youtube'){ try{ yt.seekTo(t, true); }catch(e){} } else if(video){ try{ video.currentTime = t; }catch(e){} } },\n      async play(){ if(!ready) return; if(type==='youtube'){ try{ yt.playVideo(); }catch(e){} } else if(video){ try{ await video.play(); }catch(e){} } },\n      pause(){ if(!ready) return; if(type==='youtube'){ try{ yt.pauseVideo(); }catch(e){} } else if(video){ try{ video.pause(); }catch(e){} } },\n      stop(){ if(!ready) return; this.pause(); this.seekTo(0); },\n      setRate(r){ if(type==='youtube'){ try{ yt.setPlaybackRate(r); }catch(e){} } else if(video){ video.playbackRate = r; } },\n      setVolume(v){ if(type==='youtube'){ try{ yt.setVolume(Math.round(v*100)); }catch(e){} } else if(video){ video.volume = v; } },\n      setMuted(m){ if(type==='youtube'){ try{ m? yt.mute(): yt.unMute(); }catch(e){} } else if(video){ video.muted = m; } },\n      isMuted(){ if(type==='youtube'){ try{ return yt.isMuted(); }catch(e){ return false; } } else { return !!(video && video.muted); } },\n      isReady(){ return ready; },\n      getDuration(){ if(type==='youtube'){ try{ return yt.getDuration()||duration||0; }catch(e){ return duration||0; } } return duration || (video? video.duration||0 : 0); },\n      getType(){ return type; },\n      getProvider(){ return provider; },\n    };\n  }\n\n  async function apiFetch(url){\n    const res = await fetch('/api/fetch', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({url}) });\n    if(!res.ok){ throw new Error('HTTP '+res.status); }\n    const data = await res.json();\n    if(data.status !== 'ok'){ throw new Error(data.message || 'Extraction failed'); }\n    data.originalUrl = url; // for YT fallback id parsing\n    return data;\n  }\n\n  function extractYouTubeId(u){ try{ const m = u.match(/[?&]v=([^&]+)/) || u.match(/youtu\\.be\\/([^?&]+)/); return m? m[1] : null; }catch(e){ return null; } }\n\n  async function loadUrlIntoPlayer(url, player, statusEl){\n    setStatus(statusEl, 'Fetching...');\n    try{\n      const meta = await apiFetch(url);\n      setStatus(statusEl, 'Loading sources...');\n      await player.loadFromSources(meta);\n      updateMasterDuration();\n    }catch(e){ setStatus(statusEl, 'Error: '+e.message); }\n  }\n\n  const panes = Array.from({length:NUM_PANES}, (_,i)=> createPane(i));\n\n  function updateMasterDuration(){\n    const durations = panes.map(p=> p.player.getDuration() || 0).filter(Boolean);\n    const candidateMax = Math.max(0, ...durations);\n    // Only grow the master duration; never shrink when a shorter video loads\n    const epsilon = 0.25; // seconds tolerance\n    if (!isFinite(state.masterDuration) || state.masterDuration <= 0 || candidateMax > state.masterDuration + epsilon) {\n      state.masterDuration = candidateMax;\n      const seek = document.getElementById('seek');\n      const newMax = Math.max(10, Math.ceil(state.masterDuration || 0));\n      seek.max = String(newMax);\n      if (durtime) { durtime.textContent = hhmmss(state.masterDuration || 0); }\n      // Recompute fill based on current value vs new max\n      const curVal = Number(seek.value) || 0;\n      const pct = newMax > 0 ? Math.max(0, Math.min(100, (curVal / newMax) * 100)) : 0;\n      seek.style.setProperty('--seek-fill', pct + '%');\n    }\n  }\n\n  const btnPlay = document.getElementById('play');\n  const btnPlayAll = document.getElementById('play-all');\n  const btnPause = document.getElementById('pause');\n  const btnStop = document.getElementById('stop');\n  const seek = document.getElementById('seek');\n  const curtime = document.getElementById('curtime');\n  const durtime = document.getElementById('durtime');\n  const rate = document.getElementById('rate');\n  const volume = document.getElementById('volume');\n  const muteAll = document.getElementById('mute');\n  const resync = document.getElementById('resync');\n  const fullscreenBtn = document.getElementById('fullscreen');\n  const syncIndicator = document.getElementById('sync-indicator');\n\n  // Fullscreen functionality\n  function toggleFullscreen(event){\n    event.preventDefault(); // Prevent any form submission or default button behavior\n    event.stopPropagation(); // Stop event bubbling\n    \n    try {\n      if (!document.fullscreenElement && !document.webkitFullscreenElement) {\n        // Enter fullscreen\n        if (document.documentElement.requestFullscreen) {\n          document.documentElement.requestFullscreen().catch(console.error);\n        } else if (document.documentElement.webkitRequestFullscreen) {\n          document.documentElement.webkitRequestFullscreen();\n        } else {\n          console.log('Fullscreen API not supported');\n        }\n      } else {\n        // Exit fullscreen\n        if (document.exitFullscreen) {\n          document.exitFullscreen().catch(console.error);\n        } else if (document.webkitExitFullscreen) {\n          document.webkitExitFullscreen();\n        }\n      }\n    } catch (error) {\n      console.error('Fullscreen error:', error);\n    }\n  }\n\n  // Listen for fullscreen changes to update button text\n  document.addEventListener('fullscreenchange', ()=>{\n    fullscreenBtn.textContent = document.fullscreenElement ? 'Exit Fullscreen' : 'Fullscreen';\n  });\n  document.addEventListener('webkitfullscreenchange', ()=>{\n    fullscreenBtn.textContent = document.webkitFullscreenElement ? 'Exit Fullscreen' : 'Fullscreen';\n  });\n\n  btnPlay.addEventListener('click', async ()=>{ const target = Number(seek.value)||0; await broadcastSeek(target); await broadcastPlay(); });\n  btnPlayAll.addEventListener('click', async ()=>{ await broadcastPlay(); });\n  btnPause.addEventListener('click', ()=> broadcastPause());\n  btnStop.addEventListener('click', async ()=>{ await broadcastPause(); await broadcastSeek(0); });\n  rate.addEventListener('change', ()=> broadcastRate(Number(rate.value)));\n  volume.addEventListener('input', ()=> broadcastVolume(Number(volume.value)));\n  muteAll.addEventListener('click', ()=>{ state.mutedAll = !state.mutedAll; broadcastMute(state.mutedAll); muteAll.textContent = state.mutedAll? 'Unmute All' : 'Mute All'; });\n  seek.addEventListener('input', ()=>{\n    const t = Number(seek.value)||0;\n    curtime.textContent = hhmmss(t);\n    const max = Number(seek.max)||1; const pct = Math.max(0, Math.min(100, (t/max)*100));\n    seek.style.setProperty('--seek-fill', pct+'%');\n  });\n  seek.addEventListener('change', async ()=>{ const t = Number(seek.value)||0; await broadcastSeek(t); });\n  resync.addEventListener('click', async ()=>{ const t = state.lastKnownTime||0; await broadcastSeek(t); });\n  fullscreenBtn.addEventListener('click', toggleFullscreen);\n\n  async function broadcastPlay(){ await Promise.all(panes.map(async p=> p.player.play())); }\n  function broadcastPause(){ panes.forEach(p=> p.player.pause()); }\n  async function broadcastSeek(t){ await Promise.all(panes.map(async p=> p.player.seekTo(t))); }\n  function broadcastRate(r){ panes.forEach(p=> p.player.setRate(r)); const v = Number(rate.value||'1'); panes.forEach(p=> p.player.setRate(v)); }\n  function broadcastVolume(v){ panes.forEach(p=> p.player.setVolume(v)); }\n  function broadcastMute(m){ panes.forEach(p=> p.player.setMuted(m)); }\n\n  let lastCorrection = 0;\n  setInterval(()=>{\n    const times = panes.map(p=> p.player.getCurrentTime()||0);\n    if(times.every(t=> t===0)) return;\n    const minT = Math.min(...times);\n    const maxT = Math.max(...times);\n    const drift = maxT - minT;\n    state.lastKnownTime = maxT;\n    const threshold = 0.50;\n    syncIndicator.textContent = `Sync: drift ${drift.toFixed(2)}s`;\n    syncIndicator.className = 'badge'+(drift>threshold? ' warn':'');\n    const now = performance.now();\n    // Disabled automatic sync correction to allow individual video seeking\n    // if(drift>threshold && now - lastCorrection > 1500){\n    //   // Only seek lagging players forward; avoid touching the leader to reduce stalls\n    //   panes.forEach(p=> { const t = p.player.getCurrentTime()||0; if((maxT - t) > threshold){ p.player.seekTo(maxT - 0.1); } });\n    //   lastCorrection = now;\n    // }\n    const dur = state.masterDuration || 0; if(dur>0){ const val = Math.min(dur, maxT); seek.value = String(val); if(curtime){ curtime.textContent = hhmmss(val); } const pct = Math.max(0, Math.min(100, (val/dur)*100)); seek.style.setProperty('--seek-fill', pct+'%'); }\n  }, 1000);\n})();\n","size_bytes":19487},"frontend/public/movies.js":{"content":"(function(){\n  const NUM_PANES = 4;\n  const grid = document.getElementById('grid');\n  const state = { \n    loaded: 0, \n    masterDuration: 100, // 100 seconds default \"duration\" for websites\n    lastKnownTime: 0,\n    isPlaying: false,\n    playbackRate: 1\n  };\n\n  // PaneController class to manage individual website playback\n  class PaneController {\n    constructor(iframe, statusEl) {\n      this.iframe = iframe;\n      this.statusEl = statusEl;\n      this.isPlaying = false;\n      this.currentTime = 0;\n      this.duration = 100; // Default 100 seconds\n      this.playbackRate = 1;\n      this.scrollInterval = null;\n      this.maxScroll = 0;\n    }\n\n    async play() {\n      if (this.isPlaying) return;\n      this.isPlaying = true;\n      \n      if (this.iframe && this.iframe.contentDocument) {\n        this.updateMaxScroll();\n        this.startAutoScroll();\n        setStatus(this.statusEl, 'Playing...');\n      } else {\n        setStatus(this.statusEl, 'Cannot play - cross-origin restrictions');\n      }\n    }\n\n    pause() {\n      this.isPlaying = false;\n      if (this.scrollInterval) {\n        clearInterval(this.scrollInterval);\n        this.scrollInterval = null;\n      }\n      setStatus(this.statusEl, 'Paused');\n    }\n\n    stop() {\n      this.pause();\n      this.currentTime = 0;\n      this.seekTo(0);\n      setStatus(this.statusEl, 'Stopped');\n    }\n\n    seekTo(timePercent) {\n      this.currentTime = (timePercent / 100) * this.duration;\n      \n      if (this.iframe && this.iframe.contentDocument) {\n        try {\n          this.updateMaxScroll();\n          const targetScroll = (timePercent / 100) * this.maxScroll;\n          this.iframe.contentWindow.scrollTo(0, targetScroll);\n        } catch(e) {\n          // Cross-origin restrictions - cannot scroll\n        }\n      }\n    }\n\n    setRate(rate) {\n      this.playbackRate = rate;\n      if (this.isPlaying) {\n        this.pause();\n        this.play(); // Restart with new rate\n      }\n    }\n\n    updateMaxScroll() {\n      if (this.iframe && this.iframe.contentDocument) {\n        try {\n          const doc = this.iframe.contentDocument;\n          this.maxScroll = Math.max(\n            doc.body.scrollHeight - doc.documentElement.clientHeight,\n            0\n          );\n        } catch(e) {\n          this.maxScroll = 1000; // Default fallback\n        }\n      }\n    }\n\n    startAutoScroll() {\n      if (this.scrollInterval) {\n        clearInterval(this.scrollInterval);\n      }\n\n      // Calculate scroll speed based on playback rate\n      const baseScrollSpeed = 2; // pixels per interval\n      const scrollSpeed = baseScrollSpeed * this.playbackRate;\n      const intervalTime = 100; // 100ms intervals\n\n      this.scrollInterval = setInterval(() => {\n        if (!this.isPlaying) return;\n\n        if (this.iframe && this.iframe.contentDocument) {\n          try {\n            const currentScroll = this.iframe.contentWindow.pageYOffset || 0;\n            const newScroll = currentScroll + scrollSpeed;\n            \n            this.updateMaxScroll();\n            \n            if (newScroll >= this.maxScroll) {\n              // Reached end, pause playback\n              this.pause();\n              this.currentTime = this.duration;\n              setStatus(this.statusEl, 'Playback complete');\n              return;\n            }\n\n            this.iframe.contentWindow.scrollTo(0, newScroll);\n            \n            // Update current time based on scroll position\n            this.currentTime = (newScroll / this.maxScroll) * this.duration;\n            \n          } catch(e) {\n            // Cross-origin restrictions\n            this.pause();\n            setStatus(this.statusEl, 'Cannot auto-scroll - cross-origin restrictions');\n          }\n        }\n      }, intervalTime);\n    }\n\n    getCurrentTime() {\n      return this.currentTime;\n    }\n\n    getDuration() {\n      return this.duration;\n    }\n\n    isReady() {\n      return this.iframe && this.iframe.src;\n    }\n  }\n\n  function createPane(index){\n    const pane = document.createElement('div');\n    pane.className = 'pane';\n    pane.dataset.index = index;\n\n    const topbar = document.createElement('div');\n    topbar.className = 'topbar';\n    const input = Object.assign(document.createElement('input'), { type:'text', placeholder:'Paste website URL...' });\n    const loadBtn = Object.assign(document.createElement('button'), { textContent:'Load' });\n    topbar.append(input, loadBtn);\n\n    const status = document.createElement('div');\n    status.className = 'status';\n    status.textContent = 'Idle';\n\n    const websiteWrap = document.createElement('div');\n    websiteWrap.className = 'website-wrap';\n\n    const small = document.createElement('div');\n    small.className = 'small-controls';\n    const refreshBtn = Object.assign(document.createElement('button'), { textContent:'Refresh' });\n    const hideBtn = Object.assign(document.createElement('button'), { textContent:'Hide' });\n    const gadBtn = Object.assign(document.createElement('button'), { textContent:'GAD' });\n    small.append(refreshBtn, hideBtn, gadBtn);\n    websiteWrap.appendChild(small);\n\n    const container = document.createElement('div');\n    container.style.position = 'absolute';\n    container.style.left = '0';\n    container.style.top = '0';\n    container.style.right = '0';\n    container.style.bottom = '0';\n    websiteWrap.appendChild(container);\n\n    // Create individual controls container\n    const individualControls = document.createElement('div');\n    individualControls.className = 'individual-controls';\n    individualControls.style.display = 'none'; // Hidden by default\n    \n    // Individual control elements for websites (now with playback controls)\n    const indPlayBtn = Object.assign(document.createElement('button'), { textContent:'Play' });\n    const indPauseBtn = Object.assign(document.createElement('button'), { textContent:'Pause' });\n    const indSeek = Object.assign(document.createElement('input'), { \n      type:'range', min:'0', max:'100', step:'0.01', value:'0', className:'individual-seek'\n    });\n    const indCurTime = Object.assign(document.createElement('span'), { \n      textContent:'0:00', className:'time-badge'\n    });\n    const indDurTime = Object.assign(document.createElement('span'), { \n      textContent:'1:40', className:'time-badge' \n    });\n    \n    // Individual speed control for this website only\n    const indSpeedSelect = document.createElement('select');\n    indSpeedSelect.innerHTML = `\n      <option value=\"0.5\">0.5x</option>\n      <option value=\"1\" selected>1x</option>\n      <option value=\"1.5\">1.5x</option>\n      <option value=\"2\">2x</option>\n      <option value=\"5\">5x</option>\n    `;\n    \n    const indRefreshBtn = Object.assign(document.createElement('button'), { textContent:'Refresh' });\n    const indBackBtn = Object.assign(document.createElement('button'), { textContent:'← Back' });\n    const indForwardBtn = Object.assign(document.createElement('button'), { textContent:'Forward →' });\n    const indHomeBtn = Object.assign(document.createElement('button'), { textContent:'Home' });\n    \n    individualControls.append(indPlayBtn, indPauseBtn, indCurTime, indSeek, indDurTime, indSpeedSelect, indRefreshBtn, indBackBtn, indForwardBtn, indHomeBtn);\n    \n    pane.append(topbar, status, websiteWrap, individualControls);\n\n    const website = buildWebsitePlayer(container, status);\n\n    loadBtn.addEventListener('click', async ()=>{\n      const url = input.value.trim();\n      if(!url){ setStatus(status, 'Please paste a URL'); return; }\n      await loadUrlIntoWebsite(url, website, status);\n    });\n\n    refreshBtn.addEventListener('click', ()=>{\n      website.refresh();\n    });\n\n    hideBtn.addEventListener('click', ()=>{\n      if(container.style.display === 'none'){ container.style.display = ''; hideBtn.textContent = 'Hide'; }\n      else { container.style.display = 'none'; hideBtn.textContent = 'Show'; }\n    });\n\n    // GAD button to toggle individual controls\n    gadBtn.addEventListener('click', ()=>{\n      if(individualControls.style.display === 'none'){\n        individualControls.style.display = 'flex';\n        gadBtn.textContent = 'Hide Controls';\n      } else {\n        individualControls.style.display = 'none'; \n        gadBtn.textContent = 'GAD';\n      }\n    });\n\n    // Individual control event handlers (only for this website)\n    indPlayBtn.addEventListener('click', async ()=>{ \n      await website.controller.play(); \n    });\n    \n    indPauseBtn.addEventListener('click', ()=>{ \n      website.controller.pause(); \n    });\n    \n    indSeek.addEventListener('input', ()=>{\n      const t = Number(indSeek.value)||0;\n      const duration = website.controller.getDuration();\n      const time = (t / 100) * duration;\n      indCurTime.textContent = hhmmss(time);\n      const pct = Math.max(0, Math.min(100, t));\n      indSeek.style.setProperty('--seek-fill', pct+'%');\n    });\n    \n    indSeek.addEventListener('change', async ()=>{ \n      const t = Number(indSeek.value)||0; \n      website.controller.seekTo(t); \n    });\n\n    // Individual speed control event handler (only affects this website)\n    indSpeedSelect.addEventListener('change', ()=>{\n      const rate = Number(indSpeedSelect.value);\n      website.controller.setRate(rate);\n    });\n    \n    indRefreshBtn.addEventListener('click', ()=>{ \n      website.refresh(); \n    });\n    \n    indBackBtn.addEventListener('click', ()=>{ \n      website.goBack(); \n    });\n    \n    indForwardBtn.addEventListener('click', ()=>{ \n      website.goForward(); \n    });\n\n    indHomeBtn.addEventListener('click', ()=>{ \n      website.goHome(); \n    });\n\n    // Update individual controls periodically for this website only\n    setInterval(()=>{\n      if(individualControls.style.display !== 'none' && website.controller.isReady()){\n        const currentTime = website.controller.getCurrentTime() || 0;\n        const duration = website.controller.getDuration() || 0;\n        \n        if(duration > 0){\n          indSeek.max = '100';\n          const percent = (currentTime / duration) * 100;\n          indSeek.value = String(Math.min(100, percent));\n          indCurTime.textContent = hhmmss(currentTime);\n          indDurTime.textContent = hhmmss(duration);\n          \n          const pct = Math.max(0, Math.min(100, percent));\n          indSeek.style.setProperty('--seek-fill', pct+'%');\n        }\n      }\n    }, 1000);\n\n    grid.appendChild(pane);\n    return { pane, input, loadBtn, status, website };\n  }\n\n  function setStatus(el, text){ el.textContent = text; }\n  function hhmmss(sec){ if(!isFinite(sec)) return '0:00'; const s = Math.floor(sec%60).toString().padStart(2,'0'); const m = Math.floor(sec/60)%60; const h = Math.floor(sec/3600); return (h>0? h+':'+String(m).padStart(2,'0') : m)+':'+s; }\n\n  function buildWebsitePlayer(mount, statusEl){\n    let iframe = null;\n    let ready = false;\n    let currentUrl = '';\n    let homeUrl = '';\n    let controller = null;\n\n    function destroy(){ \n      if(controller) {\n        controller.pause();\n      }\n      if(iframe){ \n        iframe.remove(); \n        iframe = null; \n      } \n      ready = false; \n      controller = null;\n    }\n\n    function ensureIframe(){ \n      if(iframe) return iframe; \n      const frame = document.createElement('iframe'); \n      frame.style.width = '100%'; \n      frame.style.height = '100%'; \n      frame.style.border = 'none';\n      frame.sandbox = 'allow-scripts allow-same-origin allow-forms allow-popups allow-top-navigation';\n      mount.appendChild(frame); \n      iframe = frame; \n      \n      // Create controller after iframe is ready\n      setTimeout(() => {\n        controller = new PaneController(iframe, statusEl);\n      }, 1000); // Wait for iframe to load\n      \n      return frame; \n    }\n\n    return {\n      async loadFromUrl(url){\n        destroy();\n        currentUrl = url;\n        homeUrl = url; // Set home URL to the first loaded URL\n        setStatus(statusEl, `Loading: ${url}`);\n        \n        return await new Promise((resolve, reject)=>{\n          try {\n            const frame = ensureIframe();\n            \n            const onLoad = ()=>{\n              frame.removeEventListener('load', onLoad);\n              ready = true;\n              setStatus(statusEl, `Ready: ${url}`);\n              resolve();\n            };\n            \n            const onError = ()=>{\n              frame.removeEventListener('error', onError);\n              setStatus(statusEl, `Error loading: ${url}`);\n              reject(new Error('Failed to load website'));\n            };\n            \n            frame.addEventListener('load', onLoad);\n            frame.addEventListener('error', onError);\n            frame.src = url;\n          } catch(e) {\n            setStatus(statusEl, 'Error: ' + e.message);\n            reject(e);\n          }\n        });\n      },\n      \n      refresh(){ \n        if(iframe && currentUrl){ \n          iframe.src = iframe.src; // Force refresh\n          setStatus(statusEl, `Refreshing: ${currentUrl}`);\n        } \n      },\n      \n      goBack(){ \n        if(iframe){ \n          try {\n            iframe.contentWindow.history.back();\n          } catch(e) {\n            setStatus(statusEl, 'Cannot navigate back (cross-origin)');\n          }\n        } \n      },\n      \n      goForward(){ \n        if(iframe){ \n          try {\n            iframe.contentWindow.history.forward();\n          } catch(e) {\n            setStatus(statusEl, 'Cannot navigate forward (cross-origin)');\n          }\n        } \n      },\n      \n      goHome(){ \n        if(iframe && homeUrl){ \n          iframe.src = homeUrl;\n          setStatus(statusEl, `Going home: ${homeUrl}`);\n        } \n      },\n      \n      get controller() { return controller; },\n      isReady(){ return ready; },\n      getCurrentUrl(){ return currentUrl; },\n    };\n  }\n\n  async function loadUrlIntoWebsite(url, website, statusEl){\n    setStatus(statusEl, 'Loading...');\n    try{\n      // Add protocol if missing\n      if(!url.startsWith('http://') && !url.startsWith('https://')){\n        url = 'https://' + url;\n      }\n      await website.loadFromUrl(url);\n    }catch(e){ \n      setStatus(statusEl, 'Error: ' + e.message); \n    }\n  }\n\n  const panes = Array.from({length:NUM_PANES}, (_,i)=> createPane(i));\n\n  function updateMasterDuration(){\n    const durations = panes.map(p=> p.website.controller ? p.website.controller.getDuration() : 0).filter(Boolean);\n    const candidateMax = Math.max(100, ...durations); // At least 100 seconds\n    state.masterDuration = candidateMax;\n    const seek = document.getElementById('seek');\n    const newMax = Math.max(10, Math.ceil(state.masterDuration || 0));\n    seek.max = String(newMax);\n    if (durtime) { durtime.textContent = hhmmss(state.masterDuration || 0); }\n    const curVal = Number(seek.value) || 0;\n    const pct = newMax > 0 ? Math.max(0, Math.min(100, (curVal / newMax) * 100)) : 0;\n    seek.style.setProperty('--seek-fill', pct + '%');\n  }\n\n  // Get DOM elements\n  const btnPlay = document.getElementById('play');\n  const btnPlayAll = document.getElementById('play-all');\n  const btnPause = document.getElementById('pause');\n  const btnStop = document.getElementById('stop');\n  const seek = document.getElementById('seek');\n  const curtime = document.getElementById('curtime');\n  const durtime = document.getElementById('durtime');\n  const rate = document.getElementById('rate');\n  const refreshAllBtn = document.getElementById('refresh-all');\n  const fullscreenBtn = document.getElementById('fullscreen');\n  const statusIndicator = document.getElementById('status-indicator');\n\n  // Fullscreen functionality\n  function toggleFullscreen(event){\n    event.preventDefault();\n    event.stopPropagation();\n    \n    try {\n      if (!document.fullscreenElement && !document.webkitFullscreenElement) {\n        if (document.documentElement.requestFullscreen) {\n          document.documentElement.requestFullscreen().catch(console.error);\n        } else if (document.documentElement.webkitRequestFullscreen) {\n          document.documentElement.webkitRequestFullscreen();\n        }\n      } else {\n        if (document.exitFullscreen) {\n          document.exitFullscreen().catch(console.error);\n        } else if (document.webkitExitFullscreen) {\n          document.webkitExitFullscreen();\n        }\n      }\n    } catch (error) {\n      console.error('Fullscreen error:', error);\n    }\n  }\n\n  // Listen for fullscreen changes\n  document.addEventListener('fullscreenchange', ()=>{\n    fullscreenBtn.textContent = document.fullscreenElement ? 'Exit Fullscreen' : 'Fullscreen';\n  });\n  document.addEventListener('webkitfullscreenchange', ()=>{\n    fullscreenBtn.textContent = document.webkitFullscreenElement ? 'Exit Fullscreen' : 'Fullscreen';\n  });\n\n  // Global control event handlers\n  btnPlay.addEventListener('click', async ()=>{ const target = Number(seek.value)||0; await broadcastSeek(target); await broadcastPlay(); });\n  btnPlayAll.addEventListener('click', async ()=>{ await broadcastPlay(); });\n  btnPause.addEventListener('click', ()=> broadcastPause());\n  btnStop.addEventListener('click', async ()=>{ await broadcastPause(); await broadcastSeek(0); });\n  rate.addEventListener('change', ()=> broadcastRate(Number(rate.value)));\n  seek.addEventListener('input', ()=>{\n    const t = Number(seek.value)||0;\n    curtime.textContent = hhmmss(t);\n    const max = Number(seek.max)||1; \n    const pct = Math.max(0, Math.min(100, (t/max)*100));\n    seek.style.setProperty('--seek-fill', pct+'%');\n  });\n  seek.addEventListener('change', async ()=>{ const t = Number(seek.value)||0; await broadcastSeek((t/state.masterDuration)*100); });\n\n  // Global broadcast functions\n  async function broadcastPlay(){ \n    await Promise.all(panes.map(async p=> {\n      if(p.website.controller) {\n        await p.website.controller.play();\n      }\n    })); \n    state.isPlaying = true;\n  }\n  \n  function broadcastPause(){ \n    panes.forEach(p=> {\n      if(p.website.controller) {\n        p.website.controller.pause();\n      }\n    }); \n    state.isPlaying = false;\n  }\n  \n  async function broadcastSeek(timePercent){ \n    await Promise.all(panes.map(async p=> {\n      if(p.website.controller) {\n        p.website.controller.seekTo(timePercent);\n      }\n    })); \n  }\n  \n  function broadcastRate(r){ \n    panes.forEach(p=> {\n      if(p.website.controller) {\n        p.website.controller.setRate(r);\n      }\n    }); \n    state.playbackRate = r;\n  }\n\n  // Other event listeners\n  refreshAllBtn.addEventListener('click', ()=>{ \n    panes.forEach(p=> p.website.refresh()); \n    statusIndicator.textContent = 'Refreshing all...';\n    setTimeout(()=> statusIndicator.textContent = 'Ready', 2000);\n  });\n  \n  fullscreenBtn.addEventListener('click', toggleFullscreen);\n\n  // Update master controls and status periodically\n  setInterval(()=>{\n    const loadedCount = panes.filter(p=> p.website.isReady()).length;\n    if(loadedCount > 0){\n      statusIndicator.textContent = `${loadedCount}/4 loaded`;\n    } else {\n      statusIndicator.textContent = 'Ready';\n    }\n\n    // Update master time display based on active websites\n    const times = panes.map(p=> p.website.controller ? p.website.controller.getCurrentTime() : 0).filter(Boolean);\n    if(times.length > 0){\n      const maxT = Math.max(...times);\n      state.lastKnownTime = maxT;\n      const dur = state.masterDuration || 0; \n      if(dur > 0){ \n        const val = Math.min(dur, maxT); \n        seek.value = String(val); \n        if(curtime){ curtime.textContent = hhmmss(val); } \n        const pct = Math.max(0, Math.min(100, (val/dur)*100)); \n        seek.style.setProperty('--seek-fill', pct+'%'); \n      }\n    }\n  }, 1000);\n\n})();","size_bytes":19618}},"version":1}